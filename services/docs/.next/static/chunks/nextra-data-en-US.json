{"/components/layout":{"title":"Layout","data":{"컴포넌트-만들고-스토리북에서-확인하기#컴포넌트 만들고 스토리북에서 확인하기":"","만들면서-새롭게-알게-된게-많아서-바로-정리해서-기록해보려고-한다#만들면서 새롭게 알게 된게 많아서 바로 정리해서 기록해보려고 한다.":"","box-컴포넌트부터-만들기#Box 컴포넌트부터 만들기":"비제어 컴포넌트가 될수도 있으니 ref 넣어주기\nreact.createElement로 생성\nimport { Ref } from \"react\";\nimport { BoxProps } from \"./types\";\nimport * as React from \"react\";\nconst Box = (props: BoxProps, ref: Ref<HTMLElement>) => {\n  const { as = \"div\", children } = props;\n  return React.createElement(\n    as,\n    {\n      ...props,\n      ref,\n      className: props.className,\n      style: {\n        background: \"yellow\",\n        width: \"100px\",\n        height: \"100px\",\n      },\n    },\n    children,\n  );\n};\nconst _Box = React.forwardRef(Box);\nexport { _Box as Box };","forwardref#forwardRef":"","forwardref-1#forwardRef":"React에서 특수한 목적으로 사용되기 때문에 일반적인 용도로 사용할 수 없는 prop이 몇 가지 있습니다. 대표적인 예로 루프를 돌면서 동일한 컴포넌트 여러 번 랜더링할 때 사용하는 key prop을 들 수 있는데요. ref prop도 마찬가지로 HTML 엘리먼트 접근이라는 특수한 용도로 사용되기 때문에 일반적인 prop으로 사용을 할 수 없습니다. \nHTML 엘리먼트가 아닌 React 컴포넌트에서 ref prop을 사용하려면 React에서 제공하는 forwardRef()라는 함수를 사용해야 합니다. React 컴포넌트를 forwardRef()라는 함수로 감싸주면, 해당 컴포넌트는 함수는 두 번째 매개 변수를 갖게 되는데, 이를 통해 외부에서 ref prop을 넘길 수 있습니다.\nimport React, { forwardRef, useRef } from \"react\";\nconst Input = forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} />;\n});\nfunction Field() {\n  const inputRef = useRef(null);\n  function handleFocus() {\n    inputRef.current.focus();\n  }\n  return (\n    <>\n      <Input ref={inputRef} />\n      <button onClick={handleFocus}>입력란 포커스</button>\n    </>\n  );\n}","타입-설계하기#타입 설계하기":"우선 폴더 구조\ncore/types.ts\n코어 타입을 설계하고 export해준다음에\n// Exclude는 뒤에오는 타입을 제외하겠다는 건데\n// AsProps에서는 IntrinsicElements에서 svg타입들을 제외하고 받겠다는 말이다.\ntype AsProps = {\n  as?: Exclude<keyof JSX.IntrinsicElements, keyof SVGElementTagNameMap>;\n};\ntype ElementProps = Omit<React.HtmlHTMLAttributes<HTMLElement>, \"as\">;\nexport type AsElementProps = AsProps & ElementProps;\n사용할 컴포넌트의 types.ts\nimport { AsElementProps } from \"../core/types\";\nexport type BoxProps = AsElementProps;","sprinkles-recipes-clsx-사용해서-동적으로-값을-바꿔-주기#Sprinkles, Recipes, clsx, 사용해서 동적으로 값을 바꿔 주기":"Sprinkls 예시\n이렇게 defineProperties로 속성들을 커스텀 해주고\nimport { defineProperties, createSprinkles } from \"@vanilla-extract/sprinkles\";\nconst space = {\n  none: 0,\n  small: \"4px\",\n  medium: \"8px\",\n  large: \"16px\",\n  // etc.\n};\nconst responsiveProperties = defineProperties({\n  conditions: {\n    mobile: {},\n    tablet: { \"@media\": \"screen and (min-width: 768px)\" },\n    desktop: { \"@media\": \"screen and (min-width: 1024px)\" },\n  },\n  defaultCondition: \"mobile\",\n  properties: {\n    display: [\"none\", \"flex\", \"block\", \"inline\"],\n    flexDirection: [\"row\", \"column\"],\n    justifyContent: [\n      \"stretch\",\n      \"flex-start\",\n      \"center\",\n      \"flex-end\",\n      \"space-around\",\n      \"space-between\",\n    ],\n    alignItems: [\"stretch\", \"flex-start\", \"center\", \"flex-end\"],\n    paddingTop: space,\n    paddingBottom: space,\n    paddingLeft: space,\n    paddingRight: space,\n    // etc.\n  },\n  shorthands: {\n    padding: [\"paddingTop\", \"paddingBottom\", \"paddingLeft\", \"paddingRight\"],\n    paddingX: [\"paddingLeft\", \"paddingRight\"],\n    paddingY: [\"paddingTop\", \"paddingBottom\"],\n    placeItems: [\"justifyContent\", \"alignItems\"],\n  },\n});\nconst colors = {\n  \"blue-50\": \"#eff6ff\",\n  \"blue-100\": \"#dbeafe\",\n  \"blue-200\": \"#bfdbfe\",\n  \"gray-700\": \"#374151\",\n  \"gray-800\": \"#1f2937\",\n  \"gray-900\": \"#111827\",\n  // etc.\n};\nconst colorProperties = defineProperties({\n  conditions: {\n    lightMode: {},\n    darkMode: { \"@media\": \"(prefers-color-scheme: dark)\" },\n  },\n  defaultCondition: \"lightMode\",\n  properties: {\n    color: colors,\n    background: colors,\n    // etc.\n  },\n});\nexport const sprinkles = createSprinkles(responsiveProperties, colorProperties);\n// It's a good idea to export the Sprinkles type too\nexport type Sprinkles = Parameters<typeof sprinkles>[0];\nUsage (css.ts)\nimport { sprinkles } from \"./sprinkles.css.ts\";\nexport const container = sprinkles({\n  display: \"flex\",\n  paddingX: \"small\",\n  // Conditional sprinkles:\n  flexDirection: {\n    mobile: \"column\",\n    desktop: \"row\",\n  },\n  background: {\n    lightMode: \"blue-50\",\n    darkMode: \"gray-700\",\n  },\n});\nUsage 2 (app.ts)\napp.ts;\nimport { sprinkles } from \"./sprinkles.css.ts\";\nconst flexDirection = Math.random() > 0.5 ? \"column\" : \"row\";\ndocument.write(`\n  <section class=\"${sprinkles({\n    display: \"flex\",\n    flexDirection,\n  })}\">\n    ...\n  </section>\n`);","chakra-ui-components-만들기#chakra ui components 만들기":"Box\nFlex\nGrid\nDivider\nGridItem","타입-선언#타입 선언":"import { vars } from \"@hojoon/themes\";\nimport { AsElementProps, StyleProps } from \"../core/types\";\nimport * as React from \"react\";\nimport { CSSProperties } from \"@vanilla-extract/css\";\nexport type BoxProps = AsElementProps & StyleProps;\nexport type DividerProps = {\n  orientation?: \"horizontal\" | \"vertical\";\n  color?: keyof typeof vars.colors.$scale;\n  size?: number;\n  variant?: \"solid\" | \"dashed\";\n} & React.HTMLAttributes<HTMLHRElement>;\nexport type FlexProps = {\n  align?: CSSProperties[\"alignItems\"];\n  basis?: CSSProperties[\"flexBasis\"];\n  direction?: CSSProperties[\"flexDirection\"];\n  grow?: CSSProperties[\"flexGrow\"];\n  justify?: CSSProperties[\"justifyContent\"];\n  shrink?: CSSProperties[\"flexShrink\"];\n  wrap?: CSSProperties[\"flexWrap\"];\n  gap?: CSSProperties[\"gap\"];\n} & BoxProps;\nexport type GridProps = {\n  autoColumns?: CSSProperties[\"gridAutoColumns\"];\n  autoFlow?: CSSProperties[\"gridAutoFlow\"];\n  autoRows?: CSSProperties[\"gridAutoRows\"];\n  column?: CSSProperties[\"gridColumn\"];\n  columnGap?: CSSProperties[\"columnGap\"];\n  gap?: CSSProperties[\"gap\"];\n  row: CSSProperties[\"gridRow\"];\n  rowGap?: CSSProperties[\"rowGap\"];\n  templateAreas?: CSSProperties[\"gridTemplateAreas\"];\n  templateColumns?: CSSProperties[\"gridTemplateColumns\"];\n  templateRows?: CSSProperties[\"gridTemplateRows\"];\n} & BoxProps;\nexport type GridItemProps = {\n  area?: CSSProperties[\"gridArea\"];\n  colEnd?: CSSProperties[\"gridColumnEnd\"];\n  colStart?: CSSProperties[\"gridColumnStart\"];\n  colSpan?: CSSProperties[\"gridColumn\"];\n  rowEnd?: CSSProperties[\"gridRowEnd\"];\n  rowStart?: CSSProperties[\"gridRowStart\"];\n  rowSpan?: CSSProperties[\"gridRow\"];\n} & BoxProps;\nGrid 컴포넌트 예시 (나머지는 생략하겠음 비슷한 방법이기때문에)\nimport { Ref } from \"react\";\nimport { GridProps } from \"./types\";\nimport * as React from \"react\";\nimport { clsx } from \"clsx\";\nimport { StyleSprinkles } from \"../core/style.css\";\nimport { extractSprinkleProps } from \"../utils/properties\";\nimport { vars } from \"@hojoon/themes\";\nconst Grid = (props: GridProps, ref: Ref<HTMLElement>) => {\n  const {\n    as = \"div\",\n    color,\n    background,\n    autoColumns,\n    autoFlow,\n    autoRows,\n    column,\n    columnGap,\n    gap,\n    row,\n    rowGap,\n    templateAreas,\n    templateColumns,\n    templateRows,\n    children,\n  } = props;\n  return React.createElement(\n    as,\n    {\n      ...props,\n      ref,\n      className: clsx([\n        StyleSprinkles(\n          extractSprinkleProps(props, Array.from(StyleSprinkles.properties)),\n        ),\n        props.className,\n      ]),\n      style: {\n        display: \"grid\",\n        gridAutoColumns: autoColumns,\n        gridAutoFlow: autoFlow,\n        gridAutoRows: autoRows,\n        gridColumnGap: columnGap,\n        gridGap: gap,\n        gridRowGap: rowGap,\n        gridTemplateColumns: templateColumns,\n        gridTemplateRows: templateRows,\n        gridTemplateAreas: templateAreas,\n        gridColumn: column,\n        gridRow: row,\n        color: color && vars.colors.$scale?.[color]?.[700],\n        background: background && vars.colors.$scale?.[background]?.[100],\n        ...props.style,\n      },\n    },\n    children,\n  );\n};\nconst _Grid = React.forwardRef(Grid);\nexport { _Grid as Grid };\nclassName을 props값에 따라 여러 클래스를 가지게 하기 위해서 clsx모듈을 사용했고 각각 StyleSprinkles 프로퍼티들을 추출해줬다.\n다만 key값들을 제대로 프롭스에 할당해주기 위해서 유틸함수를 만들어야 했는데\nutils/properties.ts\n// props를 전달해주고\n// spinkles에 해당하는 프롭스만 추출해주는 함수를 만듬\nexport const extractSprinkleProps = <T extends Object>(\n  props: T,\n  keys: (keyof T)[],\n) => {\n  const result: any = {};\n  keys.forEach((key) => {\n    if (props?.[key]) {\n      result[key] = props[key];\n    }\n  });\n  return result;\n};","레이아웃-끝#레이아웃 끝!":"아직 생소하고 따라가기 어렵지만 열심히 머리에 우겨넣고 있다. 강의 10분짜리 들어도 한시간 넘게 찾아보고 그래야함 ㅎㅎ 가성비 안좋은 머리다"}},"/components/AcoordionContext":{"title":"Acoordioncontext","data":{"공식문서#공식문서":"useContext는 컴포넌트에서 context를 읽고 구독할 수 있게 해주는 React Hook입니다.\n컴포넌트의 최상위 레벨에서 useContext를 호출하여 context를 읽고 구독합니다.\nconst value = useContext(SomeContext);\nuseContext는 전달한 context에 대한 context 값을 반환합니다. context 값을 결정하기 위해 React는 컴포넌트 트리를 검색하고 특정 context에 대해 위에서 가장 가까운 context provider를 찾습니다.","return-context#Return Context":"읽다보면 중요한 말이 있다.\nuseContext는 호출하는 컴포넌트에 대한 context 값을 반환합니다. 이 값은 호출한 컴포넌트에서 트리상 위에 있는 가장 가까운 SomeContext.Provider에 전달된 value입니다. 이러한 provider가 없는 경우 반환되는 값은 해당 context에 대해 createContext에 전달한 defaultValue가 됩니다. 반환된 값은 항상 최신 값입니다.\nReact는 context가 변경되면 context를 읽는 컴포넌트를 자동으로 리렌더링합니다.","스포-느낌의-작성이지만-context-api는-전역-상태를-할수있게-해주는-일종의-수단일-뿐이라는-것이다#스포 느낌의 작성이지만 context api는 전역 상태를 할수있게 해주는 일종의 수단일 뿐이라는 것이다.":"","사용법#사용법":"이 글을 쓰는 목적이다. ㅋㅋ 맨날 쓸때마다 헷갈리고 정리가 안된 상태로 막 갖다붙이니까 더 뒤죽박죽 되는거 같아서 나만의 순서를 만들어서 정리해보려고 한다.","1-createcontext#1. createContext":"export const AccordionContext =\n  createContext <\n  AccordionContextType >\n  {\n    activeItems: [],\n    setActiveItem: () => {},\n  };","2-context객체의-provider-컴포넌트-불러오기#2. context객체의 provider 컴포넌트 불러오기":"사실은 위에 activeItems, setActiveItem이 context를 만들때는 설계되어 있지 않을수도 있다.\n그래서 우선 컨텍스트 하나 만들어놓고 provider 컴포넌트를 만든다고 생각하면 좀 편한거 같다.\nconst Accordion = (props: AccordionProps, ref: React.Ref<HTMLDivElement>) => {\n  const { defaultActiveItems = [], children, className, ...rest } = props;\n  const [activeItems, setActiveItems] = useState<string[]>(defaultActiveItems);\n  const handleSetActiveItem = (item: string) => {\n    if (activeItems.includes(item)) {\n      setActiveItems(activeItems.filter((activeItem) => activeItem !== item));\n    } else {\n      setActiveItems([...activeItems, item]);\n    }\n  };\n  return (\n    <AccordionContext.Provider\n      value={{\n        activeItems,\n        setActiveItem: handleSetActiveItem,\n      }}\n    >\n      <div {...rest} ref={ref} className={clsx([accordionStyle, className])}>\n        {children}\n      </div>\n    </AccordionContext.Provider>\n  );\n};\nconst _Accordion = React.forwardRef(Accordion);\nexport { _Accordion as Accordion };\n코드로만 보면 지금 무슨말 하는지 이해가 안갈수도 있는데 일단 결과물 자체는 재사용 가능한 Accordion UI 컴포넌트이다.","compound-pattern-component#Compound Pattern Component":"<Accordion defaultActiveItems={[\"목록1\"]} style={{ width: \"500px\" }}>\n  <AccordionItem itemName=\"목록1\">\n    <AccordionButton>\n      <Heading color=\"gray\" fontSize=\"lg\">\n        목록 1\n      </Heading>\n    </AccordionButton>\n    <AccordionPanel>\n      <Text color=\"gray\" fontSize=\"md\">\n        내용입니다.\n      </Text>\n    </AccordionPanel>\n  </AccordionItem>\n  <AccordionItem itemName=\"목록2\">\n    <AccordionButton>\n      <Heading color=\"gray\" fontSize=\"lg\">\n        목록 2\n      </Heading>\n    </AccordionButton>\n    <AccordionPanel>\n      <Text color=\"gray\" fontSize=\"md\">\n        내용입니다.\n        <br />\n        내용입니다.\n      </Text>\n    </AccordionPanel>\n  </AccordionItem>\n</Accordion>","마지막은-usecontext로-context-가져와서-쓰는-것#마지막은 useContext로 context 가져와서 쓰는 것":"export const useAccordionContext = () => useContext(AccordionContext);","사용-예시#사용 예시":"컴파운드 패턴이기 때문에 props drilling을 피해주거나 계속 전달해줘야 하는데 사용하는 아코디언 버튼이나, 아이템, 판넬 컴포넌트에서 context값을 불러 올 수 있다.\nAccordionPanel.tsx;\nconst { activeItems } = useAccordionContext();\nAccordionButton.tsx;\nconst { setActiveItem } = useAccordionContext();\n이렇게 쓸 수 있다.","주의#주의":"React는 변경된 value를 받는 provider부터 시작해서 해당 context를 사용하는 자식들에 대해서까지 전부 자동으로 리렌더링합니다. 이전 값과 다음 값은 Object.is로 비교합니다. memo로 리렌더링을 건너뛰어도 새로운 context 값을 수신하는 자식들을 막지는 못합니다..\nuseContext()는 항상 그것을 호출하는 컴포넌트 위의 가장 가까운 provider를 찾습니다. useContext()를 호출하는 컴포넌트 내의 provider는 고려하지 않습니다.\ncreateContext(defaultValue) 호출의 기본값은 오직 위쪽에 일치하는 provider가 전혀 없는 경우에만 적용된다는 점에 유의하세요. 부모 트리 어딘가에 SomeContext.Provider value= 컴포넌트가 있는 경우, useContext(SomeContext)를 호출하는 컴포넌트는 undefined를 context 값으로 받습니다.","렌더링-최적화#렌더링 최적화":"여기서 context 값은 두 개의 프로퍼티를 가진 JavaScript 객체이며, 그 중 하나는 함수입니다. MyApp이 리렌더링할 때마다(예: 라우트 업데이트), 이것은 다른 함수를 가리키는 다른 객체가 될 것이므로 React는 useContext(AuthContext)를 호출하는 트리 깊숙한 곳의_ 모든 컴포넌트도 리렌더링해야 합니다._\n소규모 앱에서는 문제가 되지 않습니다. 그러나 currentUser와 같은 기초 데이터가 변경되지 않았다면 리렌더링할 필요가 없습니다. React가 이 사실을 활용할 수 있도록 login 함수를 useCallback으로 감싸고 객체 생성은 useMemo로 감싸면 됩니다. 이것은 성능 최적화를 위한 것입니다\nconst AuthContxt = createContext({\n  currentUser, login\n})\nfunction MyApp() {\n  const [currentUser, setCurrentUser] = useState(null);\n  function login(response) {\n    storeCredentials(response.credentials);\n    setCurrentUser(response.user);\n  }\n  return (\n    <AuthContext.Provider value={{ currentUser, login }}>\n      <Page />\n    </AuthContext.Provider>\n  );\n}\n즉, context를 구독하고 있는 모든 컴포넌트는 상태가 변경될 때마다 모두 리렌더링이 일어난다.","최적화하기-공식문서#최적화하기 (공식문서)":"import { useCallback, useMemo } from 'react';\nfunction MyApp() {\n  const [currentUser, setCurrentUser] = useState(null);\n  const login = useCallback((response) => {\n    storeCredentials(response.credentials);\n    setCurrentUser(response.user);\n  }, []);\n  const contextValue = useMemo(() => ({\n    currentUser,\n    login\n  }), [currentUser, login]);\n  return (\n    <AuthContext.Provider value={contextValue}>\n      <Page />\n    </AuthContext.Provider>\n  );\n}\n이 변경으로 인해 MyApp이 리렌더링해야 하는 경우에도 currentUser가 변경되지 않는 한 useContext(AuthProvider)를 호출하는 컴포넌트는 리렌더링할 필요가 없습니다.","전역상태관리는-context#전역상태관리는 Context?":"내 생각에는 상태관리 라이브러리를 사용하는게 맞다고 생각한다. 이번에 나도 공식문서랑 여러 관련 게시글을 보면서 알게 되었는데 useContext를 잘 몰랐을때는 상태관리 라이브러리가 필요할까라고 생각도 했었다. (ㅋㅋ ) 근데 우선 context를 쓴다면 각기 다른 상태마다 생성해주어야 하고 값이 빈번하게 바뀌는 상태와 구독하고 있는 컴포넌트의 렌더링 최적화를 고려해주어야 한다.\n또한 상태관리 라이브러리는 redux, rtk, recoil 정도 사용해보았는데 액션함수와 스토어를 분리해서 관리할 수 있다는 장점도 있었던거 같다. 또한 쓰면서 생각났던건데 프론트엔드 성능 최적화를 할때 공부했던 리덕스에 내장함수 Equalityfn은 렌더링 최적화를 알아서 고려해준다는 장점도 있기 때문에 전역으로 상태관리를 하기위해서라면 상태관리 라이브러리를 사용하는게 훨씬 좋을거 같다.\ncontext api는 아코디언, 토스트와 같은 복잡한 컴포넌트 패턴에서 프롭스 드릴링을 피하고 상태관리를 효율적으로 할때 사용하기 좋은거 같다."}},"/components":{"title":"Index","data":{"컴포넌트-기술-스택#컴포넌트 기술 스택":"리액트에서만 동작 가능한 UI 컴포넌트를 만들것이다.\nCSS Framework의 제약을 두지 않는다.\nui 컴포넌트 버전 1을 만든다.\nui 컴포넌트 버전 2를 만든다.\nui 컴포넌트 버전 3을 만든다.\nui 라이브러리를 사용하다가 버그가 발견되면??\n문제가 생긴다.\n그래서 각각의 컴포넌트들을 패키지로 따로 따로 만든다.","모노레포-도입#모노레포 도입":"모노레포를 사용하는 이유\n코드 변경, 동일한 이슈를 한 번만 수정해도 일괄 적용 가능\n설정 등을 한 곳에서 관리할 수 있음\n각각의 패키지를 멀리레포로 관리하게 된다면 typescript, eslint, bundler, ci/cd 등 각각 따로 설정해줘야함\n또 각 레포지토리 별로 설정이 다르게 될 수도 있음\n새 프로젝트를 생성하는 비용이 크다.\n동일한 이슈를 수정하기 위해 각각 대응해야 함.\n코드, 컨텍스트 공유가 힘들다.","모노레포-구성#모노레포 구성":"","nx를-쓸거임#NX를 쓸거임":"Packages\nthemes, ui components, config\nServices\nstorybook, Docs, 웹 앱 빌더 서비스, 사이드 프로젝트","모노레포-설정#모노레포 설정":"npm -> yarn berry 설정\nnode_modules, packagelock.json 삭제\nyarn set version berry\nyarn\npackage.json 스크립트 yarn으로 변경\nworkspace\n루트 폴더 package.json\n  \"workspaces\":[\n    \"packages/**/*\",\n    \"services/**/*\"\n  ],\n기존 services/test에 있는 @hojoon/themes를 file기반으로 모듈을 설치했는데 디펜던시에서 삭제해주고\nyarn add @hojoon/themes 로 설치하면 끝\nnx config 추가\n홈페이지에 들어간다.\nyarn add --dev nx\n루트에 nx.json 추가\npackage.json script 추가\n\"build\": \"nx build\",\n패키지들의 의존성 관계를 그래프로 보는법\n\"graph\": \"nx run-many --target=build --graph\"\nyarn graph","모노레포-세팅은-여기까지-다음은-eslint-config설정을-해줘야-함#모노레포 세팅은 여기까지 다음은 eslint, config설정을 해줘야 함.":"","환경설정-하기#환경설정 하기":"","eslint-prettierrc-esbuild-tsconfig#(eslint, prettierrc, esbuild, tsconfig)":"yarn berry 설정까지만 하고 모노레포 처음 만들고 너무 기분 좋아서 일단 깃허브에 푸쉬하고 말았는데 갑자기 test로 만든 리액트 프로젝트에서 모듈 에러가 나고 그래서 몇시간 삽질했다.\n이후에는 prettier, eslint, tsconfig 설정도 안먹어서 모노레포랑 yarn berry 프로젝트 포기할까 했지만 괜히 혼자 겁먹은게 잘못이었다.\n왜냐면 강의 몇분만 더 들으면 설정하는법 다알려주기 때문!","1-packages-폴더에-있는-tsconfigjson을-수정해준다#1. packages 폴더에 있는 tsconfig.json을 수정해준다":"루트 폴더에 tsconfig.base.json 파일을 만들고 다른 패키지에서 루트에 있는 tsconfig.base.json 파일의 설정을 상속받는다.\nts config.base.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ESNext\", \"DOM\"],\n    \"declaration\": true,\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"jsx\": \"react-jsx\"\n  }\n}\npackages/themes/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\"\n  }\n}","2-eslint-prettier-설정해주기#2. eslint, prettier 설정해주기":"여기서 꽤 많이 삽질했다.\n루트폴더의 packages.json\n관련 패키지들을 설치해준다.\n \"devDependencies\": {\n    \"@typescript-eslint/eslint-plugin\": \"^6.5.0\",\n    \"@typescript-eslint/parser\": \"^6.5.0\",\n    \"eslint\": \"^8.48.0\",\n    \"eslint-config-prettier\": \"^9.0.0\",\n    \"eslint-plugin-import\": \"^2.28.1\",\n    \"eslint-plugin-json-format\": \"^2.0.1\",\n    \"eslint-plugin-jsx-a11y\": \"^6.7.1\",\n    \"eslint-plugin-react\": \"^7.33.2\",\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\n    \"eslint-plugin-simple-import-sort\": \"^10.0.0\",\n    \"eslint-plugin-storybook\": \"^0.6.13\",\n    \"nx\": \"^17.2.8\",\n    \"prettier\": \"^3.1.1\",\n    \"typescript\": \"^5.3.3\"\n  }\n이렇게 설치하고 .eslintrc.js, .prettierrc 파일을 만들어주고 개발환경을 세팅해줄 텐데 대부분의 사람들이 vscode랑 prettier가 충돌이 나서 빨간 에러가 뜰거다. 나도 떠서 삽질많이함","해결방법#해결방법":"yarn dlx @yarnpkg/sdks vscode\n이러면 이제 에러도 해결된다.","3-또한-이제-앞으로-만들-패키지마다-build-config를-하는-것보다-별도의-build-config-패키지를-만들어서-쓸려고-한다#3. 또한 이제 앞으로 만들 패키지마다 build config를 하는 것보다 별도의 build config 패키지를 만들어서 쓸려고 한다.":"packages/esbuild-config 폴더 생성\nyarn init\nyarn add esbuild@0.16.17\nindex.js파일에 esbuild conifg 파일 작성\nconst { build } = require(\"esbuild\");\nconst run = ({ entryPoints = [\"src/index.ts\"], pkg, config = {} }) => {\n  const dev = process.argv.includes(\"--dev\");\n  const minify = !dev;\n  const watch = process.argv.includes(\"--watch\");\n  const external = Object.keys({\n    ...pkg.dependencies,\n    ...pkg.peerDependencies,\n  });\n  const baseConfig = {\n    entryPoints,\n    bundle: true,\n    minify,\n    sourcemap: true,\n    outdir: \"dist\",\n    target: \"es2019\",\n    watch,\n    external,\n    ...config,\n  };\n  Promise.all([\n    build({\n      ...baseConfig,\n      format: \"esm\",\n    }),\n    build({\n      ...baseConfig,\n      format: \"cjs\",\n      outExtension: {\n        \".js\": \".cjs\",\n      },\n    }),\n  ]).catch(() => {\n    console.error(\"Build failed\");\n    process.exit(1);\n  });\n};\nmodule.exports = run;\n-package.json 설정\n{\n  \"name\": \"@hojoon/esbuild-config\",\n  \"packageManager\": \"yarn@4.0.2\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"build\": \"echo \\\"hojoon!\\\"\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"dependencies\": {\n    \"esbuild\": \"0.16.17\"\n  }\n}\n이러고 themes 패키지 폴더로 이동해서 내가 만든 esbuild config 패키리를 설치하면 된다.\nyarn add --dev @hojoon/esbuild-themes\nbuild.js 파일 수정\nrun을 받아오고, pkg만 가져오면 된다. 나머지 설정들은 esbuild-config에서 다 기본 설정을 해줫기 때문에\nimport run from \"@hojoon/esbuild-config\";\nimport pkg from \"./package.json\" assert { type: \"json\" };\nrun({\n  pkg,\n});\n루트 폴더에서 빌드하기\nyarn build @hojoon/themes\n패키지 그래프 보기\nyarn graph","레이아웃-패키지-세팅하기#레이아웃 패키지 세팅하기":"@hojoon/react-components-layout 프로젝트 설정\nvanilla-extract 설치 & css file export","packagesreactcomponentslayout-폴더에-layout-라이브러리를-만들어줄것임#packages/react/components/layout 폴더에 layout 라이브러리를 만들어줄것임":"tsconfig 설정해주기\n{\n  \"extends\": \"../../../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\"\n  }\n}\n2.build.js vanilla-extract plugin 세팅\nimport run from \"@hojoon/esbuild-config\";\nimport pkg from \"./package.json\" assert { type: \"json\" };\nimport { vanillaExtractPlugin } from \"@vanilla-extract/esbuild-plugin\";\nconst config = {\n  plugins: [vanillaExtractPlugin()],\n};\nrun({\n  pkg,\n  config,\n});\nreact, react-dom 설치해주고 내가 만든 themes 라이브러리 peerDependencies에 추가해주기\nyarn add --dev react react-dom @types/react @types/react-dom\nyarn add --peer @ghojoon/themes react","이러고-빌드하면-dist폴더에-빌드-결과물이-만들어진다#이러고 빌드하면 dist폴더에 빌드 결과물이 만들어진다.":"","내가-만든-ui가-잘-만들어졌는지-확인하려면#내가 만든 UI가 잘 만들어졌는지 확인하려면??":"","스토리북을-세팅해준다#스토리북을 세팅해준다.":"루트 폴더에서 /services/storybook\nyarn init\nyarn workspace @hojoon/storybook dlx storybook init --type react\nyarn storybook\n스토리북 실행이 된다.\n다음으로 내가 만든 패키지 임포트해오기\nyarn add --dev @hojoon/themes @hojoon/react-components-layout\n스토리북 작성해서 확인해보기\n.storybook/preview.js에서 내가 만든 테마 파운데이션 임포트 해야함\nimport \"@hojoon/themes/themes.css\"\nblock.stories.tsx 스토리 만들어주기\nimport \"@hojoon/react-components-layout/style.css\";\nimport { Block as _Block } from \"@hojoon/react-components-layout\";\nexport default {\n  title: \"React Components/Layout/Block\",\n  component: _Block,\n  tags: [\"autodocs\"],\n  parameters: {\n    layout: \"centered\",\n  },\n};\nexport const BlockStory = {};","여기까지-스토리북-세팅이었다#여기까지 스토리북 세팅이었다.":"","추가로-실시간으로-변경사항을-반영하고-스토리북으로-확인하려면#추가로 실시간으로 변경사항을 반영하고 스토리북으로 확인하려면?":"react/components/layout packages.json 스크립트 추가\n\"dev\": \"yarn build:js --watch && yarn build:type --watch\"\n루트 폴더 packages.json 스크립트 추가\n \"dev:all\": \"yarn dev:storybook & yarn dev:packages\",\n    \"dev:storybook\": \"nx storybook @hojoon/storybook\",\n    \"dev:packages\": \"nx run-many --target=dev --projects='@hojoon/react-components-*'\"\n스크립트 명령어 실행하고 컴포넌트 색상 바꾸면 실시간으로 반영된다.\nyarn dev all","스토리북으로-다크모드-대응하기#스토리북으로 다크모드 대응하기":"yarn add -dev stroybook-addon-root-attributes\n.storybook/main.js addons에 추가해주기\ngetAbsolutePath(\"storybook-addon-root-attributes\"),\npreview.js\nimport \"@hojoon/themes/themes.css\";\n/** @type { import('@storybook/react').Preview } */\nconst preview = {\n  parameters: {\n    actions: { argTypesRegex: \"^on[A-Z].*\" },\n    controls: {\n      matchers: {\n        color: /(background|color)$/i,\n        date: /Date$/,\n      },\n    },\n    rootAttributesTooltip: true,\n    rootAttributes: [\n      {\n        root: \"body\",\n        attribute: \"class\",\n        defaultState: {\n          name: \"light\",\n          value: \"theme-light\",\n        },\n        states: [\n          {\n            name: \"dark\",\n            value: \"theme-dark\",\n          },\n        ],\n      },\n    ],\n  },\n};\nexport default preview;\n이전에 미디어쿼리로 시스템에서 다크모드 감지하는 스크립트 작성했던거 preview.js에 넣어주기\nconst initTheme = () => {\n  const isDarkTheme = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n  if (isDarkTheme) {\n    document.body.classList.add(\"theme-dark\");\n  }\n  const mediaQueryList = window.matchMedia(\"(prefers-color-scheme: dark)\");\n  mediaQueryList.addEventListener(\"change\", (e) => {\n    if (e.matches) {\n      document.body.classList.add(\"theme-dark\");\n    } else {\n      document.body.classList.remove(\"theme-dark\");\n    }\n  });\n};\ninitTheme();\n패키지들을 잘 사용하고 있는걸 볼 수 있다.","일단-스토리북이랑-빌드-패키지-개발환경-설정은-여기까지#일단 스토리북이랑 빌드 패키지 개발환경 설정은 여기까지!":"생소해서 너무 어렵기도 하지만 해보지 않았던거라 또 나름 공부하는 재미가 있다. 몰랐던 스크립트 작성이나 의존 관계들, 패키지 디펜던시에 좀 가까워지는듯?"}},"/hooks":{"title":"버튼 컴포넌트 만들기","data":{"":"그전에 공부한걸 정리할겸 디자인 시스템 컴포넌트를 만드는데 간단한 개념부터 정리해두고 가자","headless-component란#Headless Component란?":"스타일과 기능을 분리하여 설계하는 방식","장점#장점":"관심사 분리\nUI와 기능이 분리되어 각각 나누어 고민하고 개발을 하게되어 코드 품질이 좋아진다.\n유지보수 용이성\ninterface 또는 기능이 변경 될 경우 일괄로 반영할 수 있다.\n재사용성\n기능만 제공하기 때문에 다양한 곳에서 사용할 수 있게 된다.","headless-구현-방식#Headless 구현 방식":"Hooks\nCompound\nFunction as Child","우선-일반적으로-쉽게-만드는-재사용-가능한-headless하지-않은-버튼부터-만들어보자#우선 일반적으로 쉽게 만드는 재사용 가능한, Headless하지 않은 버튼부터 만들어보자":"","버튼-타입-설계-해주기#버튼 타입 설계 해주기":"이건 레이아웃 컴포넌트 만들면서 너무 많이 했다. 쉽다 설명 생략함\nimport { vars } from \"@hojoon/themes\";\nimport * as React from \"react\";\nexport type ButtonProps = {\n  color?: keyof typeof vars.colors.$scale;\n  isDisabled?: boolean;\n  isLoading?: boolean;\n  size?: \"xs\" | \"sm\" | \"md\" | \"lg\";\n  variant?: \"solid\" | \"outline\" | \"ghost\";\n  leftIcon?: React.ReactNode;\n  rightIcon?: React.ReactNode;\n} & React.ButtonHTMLAttributes<HTMLButtonElement>;","버튼-스타일-만들기#버튼 스타일 만들기":"chakra ui 버튼 디자인 시스템을 따라 만들고 있다.\nvanilla extract로 css를 구현중\nvanilla extract createvar api를 사용할 것임\nexport const enableColorVariant = createVar();\nexport const hoverColorVariant = createVar();\nexport const activeColorVariant = createVar();\noutline: {\n  border: `1px solid ${enableColorVariant}`,\n  color: enableColorVariant,\n  \"&:hover:not([disabled])\": {\n     backgroundColor: hoverColorVariant,\n    },\n  \"&:active:not([disabled])\": {\n     backgroundColor: activeColorVariant,\n    },\n      },\n동적으로 css 변수를 설정해주기 위함이다.\n이렇게 하고 컴포넌트에서 인라인으로 스타일을 줄 수 있다.\n style={{\n       ...assignInlineVars({\n         [enableColorVariant]: enableColor,\n         [hoverColorVariant]: hoverColor,\n         [activeColorVariant]: activeColor,\n       }),\n       ...style,\n     }}","결과물#결과물":"버튼에 포커스가 갔을 때 스페이스바랑 엔터키 입력에 대응하도록 함\nonkeydown 이벤트 핸들러 함수를 만들었고, role=\"button\"추가\n버튼에 왼쪽, 오른쪽 svg아이콘이 있거나 없는 경우에 맞게 스타일을 대응함\nconst Button = (props: ButtonProps, ref: React.Ref<HTMLButtonElement>) => {\n  const {\n    children,\n    variant = \"solid\",\n    size = \"md\",\n    color = \"gray\",\n    isDisabled = false,\n    style,\n    leftIcon,\n    rightIcon,\n    isLoading,\n    onKeyDown,\n  } = props;\n  const enableColor = vars.colors.$scale[color][500];\n  const hoverColor =\n    variant === \"solid\"\n      ? vars.colors.$scale[color][600]\n      : vars.colors.$scale[color][50];\n  const activeColor =\n    variant === \"solid\"\n      ? vars.colors.$scale[color][700]\n      : vars.colors.$scale[color][100];\n  const disabled = isDisabled || isLoading;\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLButtonElement>) => {\n    onKeyDown?.(e);\n    if (e.key === \"Enter\" || e.key === \"13\") {\n      e.preventDefault();\n      e.currentTarget.click();\n    }\n  };\n  return (\n    <button\n      // 기능\n      {...props}\n      onKeyDown={handleKeyDown}\n      role=\"button\"\n      data-loading={isLoading}\n      disabled={disabled}\n      ref={ref}\n      // 디자인\n      className={clsx([\n        buttonStyle({\n          size,\n          variant,\n        }),\n      ])}\n      style={{\n        ...assignInlineVars({\n          [enableColorVariant]: enableColor,\n          [hoverColorVariant]: hoverColor,\n          [activeColorVariant]: activeColor,\n        }),\n        ...style,\n      }}\n    >\n      {isLoading && <div className={spinnerStyle({ size })}></div>}\n      {leftIcon && <span>{leftIcon}</span>}\n      <span>{children}</span>\n      {rightIcon && <span>{rightIcon}</span>}\n    </button>\n  );\n};\nconst _Button = React.forwardRef(Button);\nexport { _Button as Button };","headless하게-만들기#Headless하게 만들기":"우선 이전에 만든 작업물은 dom이 버튼일때만 가정하고 만듬","button-a-div-span-input-요소일때-대응하도록-만들어주기#button, a, div, span, input 요소일때 대응하도록 만들어주기":"disabled, loading과 같은 상태는 기능을 분리하도록 할것임","타입-설계#타입 설계":"export type ButtonElementType = \"button\" | \"a\" | \"div\" | \"span\" | \"input\";\nexport type BaseButtonProps<T extends ButtonElementType = \"button\"> = {\n  elementType?: T;\n  role?: string;\n  type?: \"button\" | \"submit\" | \"reset\";\n  isDisabled?: boolean;\n  isLoading?: boolean;\n  tabIndex?: number;\n} & ComponentProps<T>;\nexport type UseButtonReturn<T> = {\n  buttonProps: HTMLAttributes<T> & {\n    role?: string;\n    type?: \"button\" | \"submit\" | \"reset\";\n    tabIndex?: number;\n    disabled?: boolean;\n    \"data-loading\": boolean;\n  };\n};","usebutton-훅-만들기#useButton 훅 만들기":"// props로 button의 상태를 받아온다.\n// 버튼 타입중 기능\n// return으로 button 또는 각 컴포넌트의 속성으로 return => 버튼에서 필요한 속성도 추가되어야 한다\nimport { BaseButtonProps, OverloadedButtonFunction } from \"./types\";\nexport const useButton: OverloadedButtonFunction = (props: any): any => {\n  const {\n    elementType = \"button\",\n    isDisabled,\n    isLoading,\n    tabIndex,\n    onKeyDown,\n    type = \"button\",\n  } = props;\n  const disabled = isDisabled || isLoading;\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    onKeyDown?.(e);\n    if (e.key === \" \" || e.key === \"Spacebar\" || e.key === \"32\") {\n      if (disabled) return;\n      if (e.defaultPrevented) return;\n      if (elementType === \"button\") return;\n      e.preventDefault();\n      (e.currentTarget as HTMLElement).click();\n      return;\n    }\n    if (e.key === \"Enter\" || e.key === \"13\") {\n      if (disabled) return;\n      if (e.defaultPrevented) return;\n      if (elementType === \"input\" && type !== \"button\") return;\n      e.preventDefault();\n      (e.currentTarget as HTMLElement).click();\n      return;\n    }\n  };\n  const baseProps = {\n    ...props,\n    \"data-loading\": isLoading,\n    tabIndex: disabled ? undefined : tabIndex ?? 0,\n    onkeydown: handleKeyDown,\n  };\n  let additionalProps = {};\n  switch (elementType) {\n    case \"button\": {\n      additionalProps = {\n        type: type ?? \"button\",\n        disabled,\n      };\n      break;\n    }\n    case \"a\": {\n      const { href, target, rel } = props as BaseButtonProps<\"a\">;\n      additionalProps = {\n        role: \"button\",\n        href: disabled ? undefined : href,\n        target: disabled ? undefined : target,\n        rel: disabled ? undefined : rel,\n        \"area-disabled\": isDisabled,\n      };\n      break;\n    }\n    case \"input\": {\n      additionalProps = {\n        role: \"button\",\n        type: props.type,\n        disabled,\n        \"area-disabled\": undefined,\n      };\n      break;\n    }\n    default: {\n      additionalProps = {\n        role: \"button\",\n        type: type ?? \"button\",\n        \"area-disabled\": isDisabled,\n      };\n      break;\n    }\n  }\n  const buttonProps = {\n    ...baseProps,\n    ...additionalProps,\n  };\n  return {\n    buttonProps,\n  };\n};","만든-usebutton-훅-가져다-쓰기#만든 useButton 훅 가져다 쓰기":"headless하게 만들기 위해서 기능과 스타일을 분리했음\n원래 만들었던 버튼 컴포넌트에서 disabled, onkeydown프롭스는 더이상 받지 않기때문에 빼줬다.\n버튼태그에 useButton으로 가져오는 buttonProps를 구조분해할당으로 넣어줌\nconst Button = (props: ButtonProps, ref: React.Ref<HTMLButtonElement>) => {\n  const { buttonProps } = useButton(props);\n  const {\n    children,\n    variant = \"solid\",\n    size = \"md\",\n    color = \"gray\",\n    style,\n    leftIcon,\n    rightIcon,\n    isLoading,\n  } = props;\n  const enableColor = vars.colors.$scale[color][500];\n  const hoverColor =\n    variant === \"solid\"\n      ? vars.colors.$scale[color][600]\n      : vars.colors.$scale[color][50];\n  const activeColor =\n    variant === \"solid\"\n      ? vars.colors.$scale[color][700]\n      : vars.colors.$scale[color][100];\n  return (\n    <button\n      // 기능\n      {...buttonProps}\n      {...props}\n      role=\"button\"\n      data-loading={isLoading}\n      ref={ref}\n      // 디자인\n      className={clsx([\n        buttonStyle({\n          size,\n          variant,\n        }),\n      ])}\n      style={{\n        ...assignInlineVars({\n          [enableColorVariant]: enableColor,\n          [hoverColorVariant]: hoverColor,\n          [activeColorVariant]: activeColor,\n        }),\n        ...style,\n      }}\n    >\n      {isLoading && <div className={spinnerStyle({ size })}></div>}\n      {leftIcon && <span>{leftIcon}</span>}\n      <span>{children}</span>\n      {rightIcon && <span>{rightIcon}</span>}\n    </button>\n  );\n};\nconst _Button = React.forwardRef(Button);\nexport { _Button as Button };","활용해서-toggle버튼-만들기#활용해서 toggle버튼 만들기":"클릭하면 상태가 바뀌는 useButton의 심화버전인 useToggle도 훅패턴으로 headless하게 만들수 있다.","개념이랑-원리는-usebutton과-크게-차이가-없으니-코드만-첨부하도록-하겠음#개념이랑 원리는 useButton과 크게 차이가 없으니 코드만 첨부하도록 하겠음":"export const useToggle = ({\n  isSelected = false,\n}: ToggleProps): UseToggleReturn => {\n  const [toggle, setToggle] = useState<boolean>(isSelected);\n  const handleToggle = useCallback(() => {\n    setToggle((prev) => !prev);\n  }, []);\n  return {\n    isSelected: toggle,\n    setSelected: setToggle,\n    toggle: handleToggle,\n  };\n};\n스토리북에서 컴포넌트 확인하기\nexport const ToggleButtonStory = {\n  render: () => {\n    const { buttonProps, isSelected } = useToggleButton(\n      {\n        elementType: \"button\",\n      },\n      false,\n    );\n    return (\n      <_Button\n        {...buttonProps}\n        variant={isSelected ? \"solid\" : \"outline\"}\n        color=\"green\"\n      >\n        {isSelected ? \"셀렉\" : \"노셀렉 \"}\n      </_Button>\n    );\n  },\n};"}},"/themes":{"title":"Installation","data":{"":"yarn add @hojoon/themes","1-디자인-시스템과-ui-라이브러리#1. 디자인 시스템과 UI 라이브러리":"","2-디자인-시스템에-기대하는-것#2. 디자인 시스템에 기대하는 것":"","디자인-시스템과-ui-라이브러리의-차이#디자인 시스템과 UI 라이브러리의 차이":"디자인 시스템\n브랜드와 제품의 일관성을 유지하고, 팀 간의 협업을 향상시켜 더 빠르고 효과적으로 UI를 디자인하고 구축하는데 도움이 됨\n사용자 인터페이스를 구축하는데 필요한 모든 요소를 정의하는 포괄적인 문서와 가이드라인 집합\nex) 컴포넌트, 패턴, 디자인 원칙, 사용 가이드라인, 툴, 스타일 가이드\nUI 라이브러리\nUI 라이브러리는 구체적인 코드를 포함하는, 재사용 가능한 UI컴포넌트들의 모음\n코드의 재사용성을 향상시키고, 팀 간의 협업을 간소화하여, 제품의 UI를 빠르게 구축하는데 도움이 된다.\nex) 실제 개발에서 사용할 수 있는 버튼, 입력 폼, 카드 등의 구현체","디자인-시스템#디자인 시스템":"Figma, sketch\nreact, vue\n네이티브용 디자인 시스템( Android, ios)","디자인-시스템에게-기대하는-것#디자인 시스템에게 기대하는 것":"형태 (style)\n색상\n타이포그라피\n컴포넌트\nAdobe Spectrum 과 Material Design","다양한-요구사항이-생긴다면-문제가-생긴다#다양한 요구사항이 생긴다면 문제가 생긴다.":"","제약과-자유로움-중-적절함을-찾아야-한다#제약과 자유로움 중 적절함을 찾아야 한다.":"","잘-만들어야-한다#잘 만들어야 한다":"너무 제약적으로 만들면 요구사항 마다 대응하기 힘들다.\n너무 자유롭게 만들면 하나하나 구현해야 된다.(useRadio처럼 함수를 구현해서 기능을 구현해야 하기 때문에)\n기능\n입력 (클릭, 타이핑)\n선택 (라디오, 체크박스, 토글)\n접근성\n컬러 대비\n키보드 네비게이션","디자인-시스템의-구조#디자인 시스템의 구조":"원칙 : 디자인과 개발에 대한 핵심 가치 및 지침 (린트, 허스키)\n테마 : 색상, 타이포그래피, 그리드, 스페이싱 등과 같은 기본 디자인 요소에 대한 지침\n컴포넌트 : 버튼, 입력란, 탭, 모달 등과 같은 재사용 가능한 UI 요소의 라이브러리\n패턴 : 여러 컴포넌트를 결합하여 만들어진 복잡한 사용자 인터페이스 요소\n도구 및 유틸리티 : 디자인 시스템을 실제 제품에 통합하기 위한 도구와 플러그인 (ui 라이브러리 , 차크라, 머터릴얼 ,shadcn)\n문서화 : 디자인 시스템의 모든 요소를 사용하는 방법 (스토리북)\n가이드라인 : 좋은 사용성, 접근성 등의 가이드와 권장사항들 (docs)\n프로세스 및 워크플로우 : 디자인 시스템 업데이트, 확장하는 것에 대한 프로세스 (검토 시스템 예시를 들만한 것은 팀 내에서 코드리뷰 규칙??)","chakra와-비슷한-디자인-시스템을-만들어볼-것인데-모든-웹환경에서-동작-가능하도록-만드는것이-목표다-테마-컴포넌트#chakra와 비슷한 디자인 시스템을 만들어볼 것인데 모든 웹환경에서 동작 가능하도록 만드는것이 목표다. (테마, 컴포넌트)":"","다-만들고-나면-스토리북과-넥스트라를-통해서-문서화를-할-것이다-스토리북-넥스트라#다 만들고 나면 스토리북과 넥스트라를 통해서 문서화를 할 것이다. (스토리북, 넥스트라)":"","디자인-토큰과-특징#디자인 토큰과 특징":"색상의 차이\noutline\n타이포그라피, 폰트의 차이\nAdobe Spectrum","디자인-토큰-동작-원리#디자인 토큰 동작 원리":"(CSS Variable) -> CSS에서 사용하는 변수\n'-' 두개로 시작 --\nvar() 함수를 지정하고 그 매개변수로는 사용자 지정 속성의 이름을 제공한다.\n리액트, 뷰, 바닐라 자바스크립트 등 거의 모든 환경에서 동작 가능\n:root {\n--main-bg-color: brown;\n}\nelement {\n  background-color: var(--main-bg-color);\n}\n// 대안 패턴\n.three {\n background-color : var(\n --my-var, //첫번째 값,\n --my-background, //첫번째 값이 없으면 두번째인 여기로\n pink // 1,2 가 없으면 여기로\n )\n}","디자인-ui-kit-설치#디자인 UI Kit 설치":"chakra ui 홈페이지 접속\nget started\n왼쪽 메뉴에서 figma 클릭\n계정이랑 연동해서 피그마에 가져오기","esbuild-기반의-라이브러리-프로젝트-설정#esbuild 기반의 라이브러리 프로젝트 설정":"모듈과 모듈 번들러\n라이브러리에서 고려해야할 것\n왜 esbuild인지?\n모듈\n파일 하나하나, 특정 기능을 갖는 작은 코드 단위, 재사용성의 유지 및 관리, 네임스페이스 관리 등의 장점이 있음\nex ) CommonsJS, ES Module\n모듈 번들러\n여러개의 파일과 모듈을 하나, 몇 개의 파일로 결합하는 도구 (번들링, 트리쉐이킹, 트랜스파일링, 로더와 플러그인)\n네트워크 통신으로 모듈을 불러와야 하는데 하나하나 불러오면 매우 느리고 도중에 인터넷이 멈추면 문제가 발생.\n속도 개선, 효과적으로 모듈 합치기, 불필요한 코드 제거\nex) webpack, rollup, vite, esbuild\n요새는 vite로 넘어가는 추세","라이브러리에서-고려해야-할-것#라이브러리에서 고려해야 할 것":"","브라우저-vs-라이브러리#브라우저 VS 라이브러리":"브라우저\n타겟이 명확하다.\n브라우저에도 동작하는 것이니 JS로 만들어야 한다.\n라이브러리\n타겟이 상대적으로 불명확하다. (어떤 모듈번들러인지, 누가 사용할 것인지, 어느 환경인지)\n어떤 언어로 쓸 것인지 ?(TS, JS)\n라이브러리에서 고려해야 할것\nCommon JS 대응\nModule JS 대응\n타입스크립트 대응 (type.d.ts)","esbuild-엄청-빠르다#esbuild 엄청 빠르다.":"GO 언어로 작성되어서 빠름.\n코드 파싱, 출력과 소스맵 생성을 모두 병렬로 처리함\n불필요한 데이터 변환과 할당이\nVite의 빠른 속도를 위해 개발 시 사전 번들링을 esbuild 기반에서 하고 있다. (프로덕트 빌드에서는 rollup 이유는 esbuild가 다 대응하지 못하기 때문에)","esbuild-설정하기#esbuild 설정하기":"우선 프로젝트 폴더를 하나 만들고 npm init\n/packages/theme 폴더 생성후 다시 npm init\nnpm i -D esbuild@0.16.17 (0.16.17 버전 설치했음)\npackage.json에 build 스크립트 추가\n \"build\": \"esbuild src/index.js --bundle --outfile=dist/index.js\"\nsrc/index.js를 빌드할거고 결과물은 dist/index.js\n간단한 sum 함수였음, 이러면 라이브러리를 만든거임\n빌드 스크립트 수정\n    \"build\": \"esbuild src/index.js --minify --format=cjs --bundle --outfile=dist/index.js\"\nesm과 commonjs 둘다 만들기\nbuild.js 파일 만들기\nimport esbuild from \"esbuild\";\n1. esm\nesbuild.build({\n  entryPoints: [\"src/index.js\"],\n  bundle: true,\n  minify: true,\n  sourcemap: true,\n  outdir: \"dist\",\n  format: \"esm\",\n});\n2.cjs\nesbuild.build({\n  entryPoints: [\"src/index.js\"],\n  bundle: true,\n  minify: true,\n  sourcemap: true,\n  outdir: \"dist\",\n  format: \"cjs\",\n  outExtension: {\n    \".js\": \".cjs\",\n  },\n});\n스크립트 파일 수정\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"npm run build:js\",\n    \"build:js\": \"node build.js\"\n  },\n병렬로 빌드 수행하기\nimport esbuild from \"esbuild\";\nPromise.all([\n  esbuild.build({\n    entryPoints: [\"src/index.js\"],\n    bundle: true,\n    minify: true,\n    sourcemap: true,\n    outdir: \"dist\",\n    format: \"esm\",\n  }),\n  esbuild.build({\n    entryPoints: [\"src/index.js\"],\n    bundle: true,\n    minify: true,\n    sourcemap: true,\n    outdir: \"dist\",\n    format: \"cjs\",\n    outExtension: {\n      \".js\": \".cjs\",\n    },\n  }),\n]).catch(() => {\n  console.error(\"build faild\");\n  process.exit(1);\n});\n공통 분리하기\nimport esbuild from \"esbuild\";\nconst baseConfig = {\n  bundle: true,\n  minify: true,\n  sourcemap: true,\n  outdir: \"dist\",\n};\nPromise.all([\n  esbuild.build({\n    ...baseConfig,\n    format: \"esm\",\n  }),\n  esbuild.build({\n    ...baseConfig,\n    format: \"cjs\",\n    outExtension: {\n      \".js\": \".cjs\",\n    },\n  }),\n]).catch(() => {\n  console.error(\"build faild\");\n  process.exit(1);\n});\nesbuild config 설정해주기\n개발환경에서는 minify 옵션까지 수행해줄 필요가 없음\n코드에 변경사항을 바로 빌드에 반영하고 싶으면 watch\nesbuild 16버전부터는 wath를 따로 함수로 빼줘야 한다고 함\nimport esbuild from \"esbuild\";\nconst dev = process.argv.includes(\"--dev\");\nconst minify = !dev;\nconst watch = process.argv.includes(\"--watch\");\nconst baseConfig = {\n  bundle: true,\n  minify,\n  sourcemap: true,\n  outdir: \"dist\",\n  target: \"es2019\",\n  watch,\n};\nPromise.all([\n  esbuild.build({\n    ...baseConfig,\n    format: \"esm\",\n  }),\n  esbuild.build({\n    ...baseConfig,\n    format: \"cjs\",\n    outExtension: {\n      \".js\": \".cjs\",\n    },\n  }),\n]).catch(() => {\n  console.error(\"build faild\");\n  process.exit(1);\n});","컬러-토큰-만들기#컬러 토큰 만들기":"차크라 피그마를 보자\n컬러 값들을 오브젝트로 빼준다.\nexport const color = {\n  black: \"#000\",\n  white: \"#fff\",\n};\nexport const whiteAlpha = {\n  50: \"rgba(255, 255, 255, 0.04)\",\n  100: \"rgba(255, 255, 255, 0.06)\",\n  200: \"rgba(255, 255, 255, 0.08)\",\n  300: \"rgba(255, 255, 255, 0.16)\",\n  400: \"rgba(255, 255, 255, 0.24)\",\n  500: \"rgba(255, 255, 255, 0.36)\",\n  600: \"rgba(255, 255, 255, 0.48)\",\n  700: \"rgba(255, 255, 255, 0.64)\",\n  800: \"rgba(255, 255, 255, 0.80)\",\n  900: \"rgba(255, 255, 255, 0.92)\",\n};\nexport const blackAlpha = {\n  50: \"rgba(0, 0, 0, 0.04)\",\n  100: \"rgba(0, 0, 0, 0.06)\",\n  200: \"rgba(0, 0, 0, 0.08)\",\n  300: \"rgba(0, 0, 0, 0.16)\",\n  400: \"rgba(0, 0, 0, 0.24)\",\n  500: \"rgba(0, 0, 0, 0.36)\",\n  600: \"rgba(0, 0, 0, 0.48)\",\n  700: \"rgba(0, 0, 0, 0.64)\",\n  800: \"rgba(0, 0, 0, 0.80)\",\n  900: \"rgba(0, 0, 0, 0.92)\",\n};\nexport const gray = {\n  50: \"#F7FAFC\",\n  100: \"#EDF2F7\",\n  200: \"#E2E8F0\",\n  300: \"#CBD5E0\",\n  400: \"#A0AEC0\",\n  500: \"#718096\",\n  600: \"#4A5568\",\n  700: \"#2D3748\",\n  800: \"#1A202C\",\n  900: \"#171923\",\n};\nexport const red = {\n  50: \"#FFF5F5\",\n  100: \"#FED7D7\",\n  200: \"#FEB2B2\",\n  300: \"#FC8181\",\n  400: \"#F56565\",\n  500: \"#E53E3E\",\n  600: \"#C53030\",\n  700: \"#9B2C2C\",\n  800: \"#822727\",\n  900: \"#63171B\",\n};\nexport const orange = {\n  50: \"#FFFAF0\",\n  100: \"#FEEBC8\",\n  200: \"#FBD38D\",\n  300: \"#F6AD55\",\n  400: \"#ED8936\",\n  500: \"#DD6B20\",\n  600: \"#C05621\",\n  700: \"#9C4221\",\n  800: \"#7B341E\",\n  900: \"#652B19\",\n};\nexport const yellow = {\n  50: \"#FFFFF0\",\n  100: \"#FEFCBF\",\n  200: \"#FAF089\",\n  300: \"#F6E05E\",\n  400: \"#ECC94B\",\n  500: \"#D69E2E\",\n  600: \"#B7791F\",\n  700: \"#975A16\",\n  800: \"#744210\",\n  900: \"#5F370E\",\n};\nexport const green = {\n  50: \"#F0FFF4\",\n  100: \"#C6F6D5\",\n  200: \"#9AE6B4\",\n  300: \"#68D391\",\n  400: \"#48BB78\",\n  500: \"#38A169\",\n  600: \"#2F855A\",\n  700: \"#276749\",\n  800: \"#22543D\",\n  900: \"#1C4532\",\n};\nexport const teal = {\n  50: \"#E6FFFA\",\n  100: \"#B2F5EA\",\n  200: \"#81E6D9\",\n  300: \"#4FD1C5\",\n  400: \"#38B2AC\",\n  500: \"#319795\",\n  600: \"#2C7A7B\",\n  700: \"#285E61\",\n  800: \"#234E52\",\n  900: \"#1D4044\",\n};\nexport const blue = {\n  50: \"#ebf8ff\",\n  100: \"#bee3f8\",\n  200: \"#90cdf4\",\n  300: \"#63b3ed\",\n  400: \"#4299e1\",\n  500: \"#3182ce\",\n  600: \"#2b6cb0\",\n  700: \"#2c5282\",\n  800: \"#2a4365\",\n  900: \"#1A365D\",\n};\nexport const cyan = {\n  50: \"#EDFDFD\",\n  100: \"#C4F1F9\",\n  200: \"#9DECF9\",\n  300: \"#76E4F7\",\n  400: \"#0BC5EA\",\n  500: \"#00B5D8\",\n  600: \"#00A3C4\",\n  700: \"#0987A0\",\n  800: \"#086F83\",\n  900: \"#065666\",\n};\nexport const purple = {\n  50: \"#FAF5FF\",\n  100: \"#E9D8FD\",\n  200: \"#D6BCFA\",\n  300: \"#B794F4\",\n  400: \"#9F7AEA\",\n  500: \"#805AD5\",\n  600: \"#6B46C1\",\n  700: \"#553C9A\",\n  800: \"#44337A\",\n  900: \"#322659\",\n};\nexport const pink = {\n  50: \"#FFF5F7\",\n  100: \"#FED7E2\",\n  200: \"#FBB6CE\",\n  300: \"#F687B3\",\n  400: \"#ED64A6\",\n  500: \"#D53F8C\",\n  600: \"#B83280\",\n  700: \"#97266D\",\n  800: \"#702459\",\n  900: \"#521B41\",\n};\nbuild하면 dist 폴더안에 컬러값이 빌드됨\nconsole 찍어보기\nimport * as theme from \"../dist/index.js\";\nObject.entries(theme.vars).forEach(([key, value]) => {\n  console.log(key, value);\n});\noutput : colors { '$static': [Getter] }\nimport * as theme from \"../dist/index.js\";\nObject.entries(theme.vars).forEach(([key, value]) => {\n  console.log(key, value.$static);\n});\noutput : colors { light: [Getter] }\nimport * as theme from \"../dist/index.js\";\nObject.entries(theme.vars).forEach(([key, value]) => {\n  console.log(key, value.$static.light);\n});\noutput :\ncolors {\n  blackAlpha: [Getter],\n  blue: [Getter],\n  color: [Getter],\n  cyan: [Getter],\n  gray: [Getter],\n  green: [Getter],\n  orange: [Getter],\n  pink: [Getter],\n  purple: [Getter],\n  red: [Getter],\n  teal: [Getter],\n  whiteAlpha: [Getter],\n  yellow: [Getter]\n}\nimport * as theme from \"../dist/index.js\";\nObject.entries(theme.vars).forEach(([key, value]) => {\n  console.log(key, value.$static.light.blue);\n});\noutput : colors {\n  '50': '#ebf8ff',\n  '100': '#bee3f8',\n  '200': '#90cdf4',\n  '300': '#63b3ed',\n  '400': '#4299e1',\n  '500': '#3182ce',\n  '600': '#2b6cb0',\n  '700': '#2c5282',\n  '800': '#2a4365',\n  '900': '#1A365D'\n}\n빌드된 결과물을 사용하는 방법\nnode fs를 이용해서 폴더 만들기\nfs.writeFileSync(\"dist/themes.css\", \"\");\nimport * as theme from \"../dist/index.js\";\nimport fs from \"fs\";\n// theme.css\n// root: {\n//  --gray-900: #171923\n// }\nconst toCssCasting = (str) => {\n  return str\n    .replace(/([a-z])(\\d)/, \"$1-$2\")\n    .replace(/([A-Z])/g, \"-$1\")\n    .toLowerCase();\n};\nconst generateThemeCssVariables = () => {\n  //여기다가 for 루프 돌린거를 푸쉬해준다.\n  const cssString = [];\n  Object.entries(theme.vars).forEach(([key, value]) => {\n    // key 가 color인 경우에\n    if (key === \"colors\") {\n      Object.entries(value.$static).forEach(([colorKey, colorValue]) => {\n        //ligth인 경우\n        if (colorKey === \"light\") {\n          const selector = \":root\";\n          const cssVariables = Object.entries(colorValue)\n            // 각각 key들을 뽑아서\n            .map(([mainKey, mainValue]) =>\n              Object.entries(mainValue)\n                .map(\n                  ([subKey, subValue]) =>\n                    `--${toCssCasting(mainKey)}-${toCssCasting(\n                      subKey,\n                    )}: ${subValue};`,\n                )\n                // 줄바꿈 해줘서 푸쉬해줌\n                .join(\"\\n\"),\n            )\n            .join(\"\\n\");\n          return cssString.push(`${selector} {\\n${cssVariables}\\n}`);\n        }\n        if (colorKey === \"dark\") {\n          const selector = \":root .theme-dark\";\n          const cssVariables = Object.entries(colorValue)\n            .map(([mainKey, mainValue]) =>\n              Object.entries(mainValue)\n                .map(\n                  ([subKey, subValue]) =>\n                    `--${toCssCasting(mainKey)}-${toCssCasting(\n                      subKey,\n                    )}: ${subValue};`,\n                )\n                .join(\"\\n\"),\n            )\n            .join(\"\\n\");\n          return cssString.push(`${selector} {\\n${cssVariables}\\n}`);\n        }\n      });\n      return;\n    }\n    const selector = \":root\";\n    const cssVariables = Object.entries(value)\n      .map(([mainKey, mainValue]) =>\n        Object.entries(mainValue)\n          .map(\n            ([subKey, subValue]) =>\n              `--${toCssCasting(mainKey)}-${toCssCasting(\n                subKey,\n              )}: ${subValue};`,\n          )\n          .join(\"\\n\"),\n      )\n      .join(\"\\n\");\n    return cssString.push(`${selector} {\\n${cssVariables}\\n}`);\n  });\n  return cssString;\n};\nconst generateThemeCss = () => {\n  const variables = generateThemeCssVariables();\n  fs.writeFileSync(\"dist/themes.css\", [...variables].join(\"\\n\"));\n};\ngenerateThemeCss();\n:root {\n--black-alpha-50: rgba(0, 0, 0, 0.04);\n--black-alpha-100: rgba(0, 0, 0, 0.06);\n--black-alpha-200: rgba(0, 0, 0, 0.08);\n--black-alpha-300: rgba(0, 0, 0, 0.16);\n--black-alpha-400: rgba(0, 0, 0, 0.24);\n--black-alpha-500: rgba(0, 0, 0, 0.36);\n--black-alpha-600: rgba(0, 0, 0, 0.48);\n--black-alpha-700: rgba(0, 0, 0, 0.64);\n--black-alpha-800: rgba(0, 0, 0, 0.80);\n--black-alpha-900: rgba(0, 0, 0, 0.92);\n--blue-50: #ebf8ff;\n--blue-100: #bee3f8;\n--blue-200: #90cdf4;\n--blue-300: #63b3ed;\n--blue-400: #4299e1;\n--blue-500: #3182ce;\n--blue-600: #2b6cb0;\n--blue-700: #2c5282;\n--blue-800: #2a4365;\n--blue-900: #1A365D;\n--color-black: #000;\n--color-white: #fff;\n--cyan-50: #EDFDFD;\n--cyan-100: #C4F1F9;\n--cyan-200: #9DECF9;\n--cyan-300: #76E4F7;\n--cyan-400: #0BC5EA;\n--cyan-500: #00B5D8;\n--cyan-600: #00A3C4;\n--cyan-700: #0987A0;\n--cyan-800: #086F83;\n--cyan-900: #065666;\n--gray-50: #F7FAFC;\n--gray-100: #EDF2F7;\n--gray-200: #E2E8F0;\n--gray-300: #CBD5E0;\n--gray-400: #A0AEC0;\n--gray-500: #718096;\n--gray-600: #4A5568;\n--gray-700: #2D3748;\n--gray-800: #1A202C;\n--gray-900: #171923;\n--green-50: #F0FFF4;\n--green-100: #C6F6D5;\n--green-200: #9AE6B4;\n--green-300: #68D391;\n--green-400: #48BB78;\n--green-500: #38A169;\n--green-600: #2F855A;\n--green-700: #276749;\n--green-800: #22543D;\n--green-900: #1C4532;\n--orange-50: #FFFAF0;\n--orange-100: #FEEBC8;\n--orange-200: #FBD38D;\n--orange-300: #F6AD55;\n--orange-400: #ED8936;\n--orange-500: #DD6B20;\n--orange-600: #C05621;\n--orange-700: #9C4221;\n--orange-800: #7B341E;\n--orange-900: #652B19;\n--pink-50: #FFF5F7;\n--pink-100: #FED7E2;\n--pink-200: #FBB6CE;\n--pink-300: #F687B3;\n--pink-400: #ED64A6;\n--pink-500: #D53F8C;\n--pink-600: #B83280;\n--pink-700: #97266D;\n--pink-800: #702459;\n--pink-900: #521B41;\n--purple-50: #FAF5FF;\n--purple-100: #E9D8FD;\n--purple-200: #D6BCFA;\n--purple-300: #B794F4;\n--purple-400: #9F7AEA;\n--purple-500: #805AD5;\n--purple-600: #6B46C1;\n--purple-700: #553C9A;\n--purple-800: #44337A;\n--purple-900: #322659;\n--red-50: #FFF5F5;\n--red-100: #FED7D7;\n--red-200: #FEB2B2;\n--red-300: #FC8181;\n--red-400: #F56565;\n--red-500: #E53E3E;\n--red-600: #C53030;\n--red-700: #9B2C2C;\n--red-800: #822727;\n--red-900: #63171B;\n--teal-50: #E6FFFA;\n--teal-100: #B2F5EA;\n--teal-200: #81E6D9;\n--teal-300: #4FD1C5;\n--teal-400: #38B2AC;\n--teal-500: #319795;\n--teal-600: #2C7A7B;\n--teal-700: #285E61;\n--teal-800: #234E52;\n--teal-900: #1D4044;\n--white-alpha-50: rgba(255, 255, 255, 0.04);\n--white-alpha-100: rgba(255, 255, 255, 0.06);\n--white-alpha-200: rgba(255, 255, 255, 0.08);\n--white-alpha-300: rgba(255, 255, 255, 0.16);\n--white-alpha-400: rgba(255, 255, 255, 0.24);\n--white-alpha-500: rgba(255, 255, 255, 0.36);\n--white-alpha-600: rgba(255, 255, 255, 0.48);\n--white-alpha-700: rgba(255, 255, 255, 0.64);\n--white-alpha-800: rgba(255, 255, 255, 0.80);\n--white-alpha-900: rgba(255, 255, 255, 0.92);\n--yellow-50: #FFFFF0;\n--yellow-100: #FEFCBF;\n--yellow-200: #FAF089;\n--yellow-300: #F6E05E;\n--yellow-400: #ECC94B;\n--yellow-500: #D69E2E;\n--yellow-600: #B7791F;\n--yellow-700: #975A16;\n--yellow-800: #744210;\n--yellow-900: #5F370E;\n}","열심히-만든-theme-패키지-쓰는법#열심히 만든 theme 패키지 쓰는법":"루트 폴더에서 service 디렉토리 만들고 test 폴더에\nnpx create-react-app test --template typescript\nnpm install file:../../packages/themes\nindex.tsx 에서\nimport \"@hojoon/themes/themes.css\";\n불러오는걸 확인할 수 있다.\n6.바꿔보자\napp.css 에서\n.App-header {\n  background-color: var(--gray-100);\n색깔이 바꼈다.\nemotion과 같은 css-in-js에서 사용하기\nimport React from \"react\";\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\nimport { ThemeProvider } from \"@emotion/react\";\nimport styled from \"@emotion/styled\";\nimport { vars } from \"@hojoon/themes\";\nconst View = () => {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <Text>\n          Edit <code>src/App.tsx</code> and save to reload.\n        </Text>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n        </a>\n      </header>\n    </div>\n  );\n};\nfunction App() {\n  const theme = {\n    color: vars.colors.$static.light,\n  };\n  return (\n    <ThemeProvider theme={theme}>\n      <View />\n    </ThemeProvider>\n  );\n}\nexport default App;\nconst Text = styled.p`\n  color: ${({ theme }) => {\n    // @ts-ignore\n    return theme.color.red[900];\n  }};\n`;\n이렇게도 사용 가능 하다.\nconst Text = styled.p`\n  color: ${vars.colors.$static.light.red[500]};\n`;\n객체 값이기 때문에 뽑아서 쓸 수도 있다.\n<Text>font color ={vars.colors.$static.light.red[500]}</Text>","여기-까지-컬러토큰-마무리-였습니다#여기 까지 컬러토큰 마무리 였습니다.":"","다크모드-대응하기#다크모드 대응하기":"chakra 에서는 각각의 컬러들을 뒤집어서 다크모드에 대응한다.\n아까 만들었던 themes/src/variables/colors/static/dark.ts 파일에 컬러값을 light와 뒤집어서 설정\nscripts/build-css-module.js\nscale 컬러값도 설정\npublic/index.html에서\n<body class=\"theme-dark\"> 하면 다크 모드 설정됨\nindex.html body태그안에 script로 다크/라이트 설정되게 가능\n리액트 코드에서 설정하지 않고 여기서 설정하는 이유는 ssr환경에서 나는 다크모드로 설정해놨는데 디폴트가 라이트모드이면 라이트모드로 로딩을 끝내고 다시 js를 실행해서 dark모드로 바뀌는 현상이 발생할 수 있다.7.스크립트 파일 작성하기\n <script>\n      const isDarkMode = window.matchMedia(\n        \"(prefers-color-scheme: dark)\"\n      ).matches;\n      if (isDarkMode) {\n        document.body.classList.add(\"theme-dark\");\n      }\n      const mediaQueryList = window.matchMedia(\"(prefers-color-scheme: dark)\");\n      mediaQueryList.addEventListener(\"change\", (e) => {\n        const isDarkMode = e.matches;\n        if (isDarkMode) {\n          document.body.classList.add(\"theme-dark\");\n        } else {\n          document.body.classList.remove(\"theme-dark\");\n        }\n      });\n    </script>\nprefers-color-scheme CSS 미디어 특성은 사용자의 시스템이 라이트 테마나 다크 테마를 사용하는지 탐지하는 데에 사용됩니다.\nlight\n사용자가 시스템에 라이트 테마를 사용하는 것을 선호하거나 선호하는 테마를 알리지 않았음을 나타냅니다.\ndark\n사용자가 시스템에 다크 테마를 사용하는 것을 선호한다고 알렸음을 나타냅니다.\n보통의 서비스에서 버튼하나로 dark/light 모드를 바꾸고 저장하려면 이때 로컬스토리지를 사용하면 된다.","타이포그라피-토큰-만들기#타이포그라피 토큰 만들기":"variables/typography.ts\nexport const fontSize = {\n  72: \"4.5rem\",\n  60: \"3.75rem\",\n  48: \"3rem\",\n  36: \"2.25rem\",\n  30: \"1.875rem\",\n  24: \"1.5rem\",\n  20: \"1.25rem\",\n  18: \"1.125rem\",\n  16: \"1rem\",\n  14: \"0.875rem\",\n  12: \"0.75rem\",\n};\nexport const fontWeight = {\n  700: \"700\",\n  600: \"600\",\n  500: \"500\",\n  400: \"400\",\n};\nexport const lineHeight = {\n  150: \"150%\",\n  133: \"133%\",\n  120: \"120%\",\n  100: \"100%\",\n};\nbuild후에 app.tsx\nconsole.log(\"!!\", classes.typography);\n적용\nconst Text = styled.p`\n  ${classes.typography.heading[\"4xl\"]}\n  color: ${vars.colors.$static.light.red[500]};\n`;\nclassName만 줘도 디자인 변경 가능\n<Text className=\"heading3xl\">","shadow-radius와-같은-그-외-토큰-만들어보기#shadow, Radius와 같은 그 외 토큰 만들어보기":"타이포그라피\n여러 가지 조합때문에 클래스로 만들어줬어야 했고\n다크모드\n각각 분리해서 만들어야 했고\ncss variable 추가만 해줘도 토큰을 만들 수 있다. (shadoe, radius, spacing)\nbox.ts\nexport const spacing = {\n  0: \"0\",\n  1: \"0.25rem\",\n  2: \"0.5rem\",\n  3: \"0.75rem\",\n  4: \"1rem\",\n  5: \"1.25rem\",\n  6: \"1.5rem\",\n  7: \"1.75rem\",\n  8: \"2rem\",\n  9: \"2.25rem\",\n  10: \"2.5rem\",\n  11: \"2.75rem\",\n  12: \"3rem\",\n  14: \"3.5rem\",\n  16: \"4rem\",\n  20: \"5rem\",\n  24: \"6rem\",\n  28: \"7rem\",\n  32: \"8rem\",\n  36: \"9rem\",\n  40: \"10rem\",\n  44: \"11rem\",\n  48: \"12rem\",\n  52: \"13rem\",\n  56: \"14rem\",\n  60: \"15rem\",\n  64: \"16rem\",\n  72: \"18rem\",\n  80: \"20rem\",\n  96: \"24rem\",\n};\nexport const radii = {\n  none: \"0\",\n  sm: \"0.125rem\",\n  base: \"0.25rem\",\n  md: \"0.375rem\",\n  lg: \"0.5rem\",\n  xl: \"0.75rem\",\n  \"2xl\": \"1rem\",\n  \"3xl\": \"1.5rem\",\n  full: \"9999px\",\n};\nexport const shadows = {\n  xs: \"0 0 0 1px rgba(0, 0, 0, 0.05)\",\n  sm: \"0px 1px 2px 0px rgba(0, 0, 0, 0.05)\",\n  base: \"0px 1px 2px 0px rgba(0, 0, 0, 0.06), 0px 1px 3px 0px rgba(0, 0, 0, 0.10)\",\n  md: \"0px 2px 4px -1px rgba(0, 0, 0, 0.06), 0px 4px 6px -1px rgba(0, 0, 0, 0.10)\",\n  lg: \"0px 4px 6px -2px rgba(0, 0, 0, 0.05), 0px 10px 15px -3px rgba(0, 0, 0, 0.10)\",\n  xl: \"0px 10px 10px -5px rgba(0, 0, 0, 0.04), 0px 20px 25px -5px rgba(0, 0, 0, 0.10)\",\n  \"2xl\": \"0px 25px 50px -12px rgba(0, 0, 0, 0.25)\",\n  inner: \"0px 2px 4px 0px rgba(0, 0, 0, 0.06) inset\",\n  darkLg:\n    \"0px 15px 40px 0px rgba(0, 0, 0, 0.40), 0px 5px 10px 0px rgba(0, 0, 0, 0.20), 0px 0px 0px 1px rgba(0, 0, 0, 0.10)\",\n  outline: \"0 0 0 3px rgba(66, 153, 225, 0.6)\",\n};\nnpm run build\napp.tsx에서 쓰기\n<Text className=\"heading2xl\">{vars.box.radii.base}</Text>","이렇게-값이-찍힌다#이렇게 값이 찍힌다.":"","중요한점#중요한점":"근데 이렇게 자동화된 스크립트 코드를 만드는것은 유지보수 측면에서 좋을 수 있으나 초기에는 좋지 않을수도 있다.\n오히려 만드는데 많은 비용이 든다.","다음편은-ui-라이브러리만들기#다음편은 UI 라이브러리만들기":""}}}